/*
The :kl-ref:`BSpline` type represents a B-spline interpolation of control points of any dimensionality using de Boor's algorithm.

The interpolator can take an optional weight vector, making the resulting curve a Non-Uniform Rational B-Spline (NURBS) curve if you wish so.

The knot vector is optional too, and when not provided an unclamped uniform knot vector will be generated internally.

Shamelessly adapted/extended from - https://github.com/thibauts/b-splines.

*/
require Math;

struct ZSpline {
	BSpline BSplines[];
	Boolean closed;
  // distance vector array
	Scalar distances[];
  Scalar restLength;
};

/// Default constructor - set to identity
inline ZSpline() {
  this.closed = 0;
}

// inline ZSpline.setFromBSplineKnot!(in BSplineKnot knots[]) {
// 	this.BSplines.push()
// 	for(UInt32 k=1; k<knots.size(); k++){
// 		BSplines.
// 		if (k>0 && knots[k].segmentStart) {

// 		}
// 	}
// }

inline UInt32 ZSpline.getSegmentFromT(in Scalar t) {
	Scalar normt = t * this.BSplines.size();
	UInt32 segment = Math_clamp(floor(normt),0.0,this.BSplines.size()-1);
	return segment;
}

inline Scalar ZSpline.normalizeT(Scalar t) {
	UInt32 noSegments = this.BSplines.size();
	return (t * noSegments-this.getSegmentFromT(t));
}


function Vec3 ZSpline.evalPosition(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  Scalar arct = this.arcLengthParam(t,keepArcLength,keepCurveLen);
  // determine subSpline and respective t ( segment and segmentT )
  UInt32 segment = this.getSegmentFromT(arct);
  Scalar segmentT = this.normalizeT(arct);
  // get the position from the curve as usual
  return this.BSplines[segment].evalPosition(segmentT, 0, 0);
}

function Vec3 ZSpline.evalPosition(Scalar t) {
  // determine subSpline and respective t ( segment and segmentT )
	UInt32 segment = this.getSegmentFromT(t);
	Scalar segmentT = this.normalizeT(t);
  // get the position from the curve as usual
	return this.BSplines[segment].evalPosition(segmentT);
}


function Vec3 ZSpline.evalTangent(Scalar t) {
	UInt32 segment = this.getSegmentFromT(t);
	Scalar segmentT = this.normalizeT(t);
	return this.BSplines[segment].evalTangent(segmentT);
}

// SCALE

function Vec3 ZSpline.evalScale(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  Scalar arct = this.arcLengthParam(t,keepArcLength,keepCurveLen);
  // determine subSpline and respective t ( segment and segmentT )
  UInt32 segment = this.getSegmentFromT(arct);
  Scalar segmentT = this.normalizeT(arct);
  return this.BSplines[segment].evalScale(segmentT);
}

function Vec3 ZSpline.evalScale(Scalar t) {
  UInt32 segment = this.getSegmentFromT(t);
  Scalar segmentT = this.normalizeT(t);
  return this.BSplines[segment].evalScale(segmentT);
}

function Quat ZSpline.evalOri(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  Scalar arct = this.arcLengthParam(t,keepArcLength,keepCurveLen);
  // determine subSpline and respective t ( segment and segmentT )
  UInt32 segment = this.getSegmentFromT(arct);
  Scalar segmentT = this.normalizeT(arct);
  return this.BSplines[segment].evalOri(segmentT);
}

// ORIENTATION

function Quat ZSpline.evalOri(Scalar t) {
	UInt32 segment = this.getSegmentFromT(t);
	Scalar segmentT = this.normalizeT(t);
	return this.BSplines[segment].evalOri(segmentT);
}

inline ZSpline.initiate!() {
	this.setDistanceVector();
}

inline ZSpline.setDistanceVector!() {
  this.distances.resize(0);
  Scalar lastVal = 0;
  if (this.BSplines.size()) {
	  for(UInt32 b=0; b<this.BSplines.size(); b++) {
	  	  for(UInt32 v=0; v<this.BSplines[b].distances.size(); v++) {
          if (v==0 && b==0) this.distances.push(0.0);
          if (v>0) this.distances.push(this.BSplines[b].distances[v] + lastVal);
  	  	}
	  	lastVal = this.distances[this.distances.size()-1];
	  }
  }
}

inline ZSpline.setRestLength!(Scalar length) {
  this.restLength = length;
}

// function Scalar ZSpline.arcLengthParam(Scalar t, Scalar keepArcLength, Scalar keepCurveLen, Scalar restLength) {
// 	UInt32 segment = this.getSegmentFromT(t);
// 	Scalar segmentT = this.normalizeT(t);
// 	return this.BSplines[segment].arcLengthParam(t, keepArcLength, keepCurveLen, restLength);
// }

function Scalar ZSpline.getCurveLength(Scalar keepCurveLen) {
  Scalar Length =  (1-keepCurveLen)*(this.distances[this.distances.size()-1]) + keepCurveLen*this.restLength;
  return Length;
}


function Scalar ZSpline.arcLengthParam(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  UInt32 curveLength = this.distances.size()-1;
  Scalar actualLength = this.distances[this.distances.size()-1];
  Scalar tipLength   = t*this.getCurveLength(keepCurveLen);
  Scalar nonArcLengthT = tipLength/actualLength;
  if (keepArcLength == 0) {
    return nonArcLengthT;
  }
  
  // tipLength is t multiplied by the maximum length
  // tipLength is the approximated curvelength at incoming param t
  
  // do a fast, binary search for the closest matching distance index
  Scalar low = 0, high = curveLength, index = 0;
  while (low < high) {
    index = low + (((high - low) / 2) | 0);  
    if (this.distances[index] < tipLength) {
      low = index + 1;
    } else {
      high = index;
    }
  }
  if (this.distances[index] > tipLength) {
    index -= 1;
  }
  
  // from the distance index, extrapolate 
  Scalar lengthBefore = this.distances[index];
  Scalar arcLenghtT   = (index + (tipLength - lengthBefore) / (this.distances[index + 1] - lengthBefore)) / curveLength;
  
  // return lerped parameterization using the blend value keepArcLength
  return (keepArcLength*arcLenghtT) + (1.0-keepArcLength)*nonArcLengthT;
}



