/*
The :kl-ref:`BSpline` type represents a B-spline interpolation of control points of any dimensionality using de Boor's algorithm.

The interpolator can take an optional weight vector, making the resulting curve a Non-Uniform Rational B-Spline (NURBS) curve if you wish so.

The knot vector is optional too, and when not provided an unclamped uniform knot vector will be generated internally.

Shamelessly adapted/extended from - https://github.com/thibauts/b-splines.

*/
require Math;

struct ZSpline {
	BSpline BSplines[];
	Boolean closed;
  // distance vector array
	Scalar distances[];
  Scalar restLength;
};

/// Default constructor - set to identity
inline ZSpline() {
  this.closed = 0;
}

// inline ZSpline.setFromBSplineKnot!(in BSplineKnot knots[]) {
// 	this.BSplines.push()
// 	for(UInt32 k=1; k<knots.size(); k++){
// 		BSplines.
// 		if (k>0 && knots[k].segmentStart) {

// 		}
// 	}
// }

inline UInt32 ZSpline.getSegmentFromT(in Scalar t) {
	Scalar normt = t * this.BSplines.size();
	UInt32 segment = Math_clamp(floor(normt),0.0,this.BSplines.size()-1);
	return segment;
}

inline Scalar ZSpline.normalizeT(Scalar t) {
	UInt32 noSegments = this.BSplines.size();
	return (t * noSegments-this.getSegmentFromT(t));
}


function Vec3 ZSpline.evalPosition(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  Scalar arct = this.arcLengthParam(t,keepArcLength,keepCurveLen);
  // determine subSpline and respective t ( segment and segmentT )
  UInt32 segment = this.getSegmentFromT(arct);
  Scalar segmentT = this.normalizeT(arct);
  // get the position from the curve as usual
  return this.BSplines[segment].evalPosition(segmentT, 0, 0);
}

function Vec3 ZSpline.evalPosition(Scalar t) {
  // determine subSpline and respective t ( segment and segmentT )
	UInt32 segment = this.getSegmentFromT(t);
	Scalar segmentT = this.normalizeT(t);
  // get the position from the curve as usual
	return this.BSplines[segment].evalPosition(segmentT);
}


function Vec3 ZSpline.evalTangent(Scalar t) {
	UInt32 segment = this.getSegmentFromT(t);
	Scalar segmentT = this.normalizeT(t);
	return this.BSplines[segment].evalTangent(segmentT);
}

// SCALE

function Vec3 ZSpline.evalScale(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  Scalar arct = this.arcLengthParam(t,keepArcLength,keepCurveLen);
  // determine subSpline and respective t ( segment and segmentT )
  UInt32 segment = this.getSegmentFromT(arct);
  Scalar segmentT = this.normalizeT(arct);
  return this.BSplines[segment].evalScale(segmentT);
}

function Vec3 ZSpline.evalScale(Scalar t) {
  UInt32 segment = this.getSegmentFromT(t);
  Scalar segmentT = this.normalizeT(t);
  return this.BSplines[segment].evalScale(segmentT);
}

function Quat ZSpline.evalOri(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  Scalar arct = this.arcLengthParam(t,keepArcLength,keepCurveLen);
  // determine subSpline and respective t ( segment and segmentT )
  UInt32 segment = this.getSegmentFromT(arct);
  Scalar segmentT = this.normalizeT(arct);
  return this.BSplines[segment].evalOri(segmentT);
}

// ORIENTATION

function Quat ZSpline.evalOri(Scalar t) {
	UInt32 segment = this.getSegmentFromT(t);
	Scalar segmentT = this.normalizeT(t);
	return this.BSplines[segment].evalOri(segmentT);
}

inline ZSpline.initiate!() {
	this.setDistanceVector();
}

inline ZSpline.setDistanceVector!() {
  this.distances.resize(0);
  Scalar lastVal = 0;
  if (this.BSplines.size()) {
	  for(UInt32 b=0; b<this.BSplines.size(); b++) {
	  	  for(UInt32 v=0; v<this.BSplines[b].distances.size(); v++) {
          if (v==0 && b==0) this.distances.push(0.0);
          if (v>0) this.distances.push(this.BSplines[b].distances[v] + lastVal);
  	  	}
	  	lastVal = this.distances[this.distances.size()-1];
	  }
  }
}


// function Scalar ZSpline.arcLengthParam(Scalar t, Scalar keepArcLength, Scalar keepCurveLen, Scalar restLength) {
// 	UInt32 segment = this.getSegmentFromT(t);
// 	Scalar segmentT = this.normalizeT(t);
// 	return this.BSplines[segment].arcLengthParam(t, keepArcLength, keepCurveLen, restLength);
// }

function Scalar ZSpline.getCurveLength(Scalar keepCurveLen) {
  Scalar Length =  (1-keepCurveLen)*(this.distances[this.distances.size()-1]) + keepCurveLen*this.restLength;
  return Length;
}


function Scalar ZSpline.arcLengthParam(Scalar t, Scalar keepArcLength, Scalar keepCurveLen) {
  UInt32 curveLength = this.distances.size()-1;
  Scalar actualLength = this.distances[this.distances.size()-1];
  Scalar tipLength   = t*this.getCurveLength(keepCurveLen);
  Scalar nonArcLengthT = tipLength/actualLength;
  if (keepArcLength == 0) {
    return nonArcLengthT;
  }
  
  // tipLength is t multiplied by the maximum length
  // tipLength is the approximated curvelength at incoming param t
  
  // do a fast, binary search for the closest matching distance index
  Scalar low = 0, high = curveLength, index = 0;
  while (low < high) {
    index = low + (((high - low) / 2) | 0);  
    if (this.distances[index] < tipLength) {
      low = index + 1;
    } else {
      high = index;
    }
  }
  if (this.distances[index] > tipLength) {
    index -= 1;
  }
  
  // from the distance index, extrapolate 
  Scalar lengthBefore = this.distances[index];
  Scalar arcLenghtT   = (index + (tipLength - lengthBefore) / (this.distances[index + 1] - lengthBefore)) / curveLength;
  
  // return lerped parameterization using the blend value keepArcLength
  return (keepArcLength*arcLenghtT) + (1.0-keepArcLength)*nonArcLengthT;
}

function UInt32[].resizeWithDefault!(UInt32 size, UInt32 defaultVal) {
  UInt32 currentSize;
  currentSize = this.size();
  this.resize(size);
  for(UInt32 i=0; i>=currentSize && i<size;i++){
    this[i] = defaultVal;
  }
}

function Scalar[].resizeWithDefault!(UInt32 size, Scalar defaultVal) {
  UInt32 currentSize;
  currentSize = this.size();
  this.resize(size);
  for(UInt32 i=0; i>=currentSize && i<size;i++){
    this[i] = defaultVal;
  }
}

function Boolean[].resizeWithDefault!(UInt32 size, Boolean defaultVal) {
  UInt32 currentSize;
  currentSize = this.size();
  this.resize(size);
  for(UInt32 i=0; i>=currentSize && i<size;i++){
    this[i] = defaultVal;
  }
}

// initiate 
function ZSpline.buildZSpline!(Mat44 mat44s[], io Boolean zeroKnots[], io Scalar weights[],  io UInt32 order[] , io UInt32 numSegs[], io Boolean clamped[], Boolean closed) {
  UInt32 s = mat44s.size();

  zeroKnots.resizeWithDefault(s,0);
  order.resizeWithDefault(s,4);
  weights.resizeWithDefault(s,1);
  numSegs.resizeWithDefault(s,25);
  order.resizeWithDefault(s,4);
  clamped.resizeWithDefault(s,1);


  Mat44 controlPoints[];
  Scalar bweights[];

  for(UInt32 m=0; m<s;m++){
    controlPoints.push(mat44s[m]);
    bweights.push(weights[m]);

    if ((!m==0 && zeroKnots[m]==1) || m==(s-1)) {
      BSpline b;
      
      // need to get this to work
      // b(controlPoints.clone(), order, closed, clamped);
      
      b.setOrder(order[m]);
      b.setClosed(closed);
      b.setClamped(clamped[m]);
      b.setNumSegs(numSegs[m]);
      b.setControlPoints(controlPoints.clone());
      b.setWeightVector(bweights.clone());

      this.BSplines.push(b);

      // reset control points and repeat last point for enxt curve segment
      controlPoints.resize(0);
      controlPoints.push(mat44s[m]);
    }
  }
  // result.setRestLength(restLength);
  this.initiate();
}


// initiate 
function ZSpline.buildZSpline!(Mat44 mat44s[]) {
  UInt32 s = mat44s.size();
  Boolean zeroKnots[];
  zeroKnots.resize(s);
  Mat44 controlPoints[];
  Boolean closed = 0;
  Boolean clamped = 1;
  UInt32 order = 4;
  UInt32 numSegs = 100;
  for(UInt32 m=0; m<s;m++){
    controlPoints.push(mat44s[m]);
    if ((!m==0 && zeroKnots[m]==1) || m==(s-1)) {
      BSpline b;
      
      // need to get this to work
      // b(controlPoints.clone(), order, closed, clamped);
      
      b.setOrder(order);
      b.setClosed(closed);
      b.setClamped(clamped);
      b.setNumSegs(numSegs);
      b.setControlPoints(controlPoints.clone());

      this.BSplines.push(b);

      // reset control points and repeat last point for enxt curve segment
      controlPoints.resize(0);
      controlPoints.push(mat44s[m]);
    }
  }
  // result.setRestLength(restLength);
  this.initiate();
}

