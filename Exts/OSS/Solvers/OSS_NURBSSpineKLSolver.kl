require Math;
require Curves;
require InlineDrawing;

object OSS_NURBSSpineKLSolver : KrakenSolver {
  NURBSCurve restCurve;
  NURBSCurve posedCurve;
  Ref <NURBSCurve> posedCurveRef;
  Ref <NURBSCurve> restCurveRef;

  Scalar params[]; 
  Vec3 altNormal[];
  Vec3 altTangent[];
  Xfo xfos[];
  Xfo outputsXfo[];
  Scalar compression[];
};

function OSS_NURBSSpineKLSolver()
{
  this.restCurve = NURBSCurve();
  this.posedCurve = NURBSCurve();
  this.posedCurveRef = this.posedCurve;
  this.restCurveRef = this.restCurve;

  this.restCurve.computeColors = false;
  this.posedCurve.computeColors = false;
}

// Return Arguments for Kraken
function KrakenSolverArg[] OSS_NURBSSpineKLSolver.getArguments() {
  KrakenSolverArg args[] = this.parent.getArguments();
  args.push(KrakenSolverArg('numDeformers', 'In', 'UInt32'));
  args.push(KrakenSolverArg('compressionAmt', 'In', 'Scalar'));
  args.push(KrakenSolverArg('controlsRest', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('controls', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('outputs', 'Out', 'Mat44[]'));
  return args;
}


operator __alignXfosTask<<<index>>>(io Xfo results[], Xfo xfos[], UInt8 alignX,  UInt8 alignY,  UInt8 alignZ)
{ 
  Xfo x = xfos[index];
  results[index] = x.align(alignX,alignY,alignZ);
}


// Solve
function OSS_NURBSSpineKLSolver.solve!(
    in Boolean drawDebug,
    in Scalar rigScale,
    in UInt32 numDeformers,
    in Scalar compressionAmt,
    in Mat44 controlsRest[],
    in Mat44 controls[],
    io Mat44 outputs[]
    )
{
  if(controls.size() != controlsRest.size())
    throw("Error in OSS_NURBSSpineKLSolver. The number of controls must match the number of controlsRest. controls.size:" + controls.size() + "; constrainees.size:" + controlsRest.size());

  UInt32 count = numDeformers;
   
  Scalar keepArcLength = 0;
  Scalar keepCurveLen = 0;
  
  // set interpolated params between a and b
  if(this.params.size() != count) {
    this.params.resize(count);
    this.xfos.resize(count);
    this.outputsXfo.resize(count);
    this.altTangent.resize(count);
    this.altNormal.resize(count);
    this.compression.resize(count);
  }

  outputs.resize(count);
  // Boolean popLast = false; 

  for(Size i=0;i<count;i++)
  {
    // this.params[i] = Float32(i) / Float32(popLast ? count : count-1);
    this.params[i] = Float32(i) / Float32(count-1);
  }

  UInt32 degree = 3;
  {
    this.posedCurve.initiate(controls, degree);

    // the rest curve does not change over time
    if(this.restCurve.numPoints != controlsRest.size())
      this.restCurve.initiate(controlsRest, degree);
  }
  
  Scalar useLocalNormal = 1; 
  Scalar followCurveTangent =1;
  Scalar followCurveNormal = 1; 

  UInt8 alignX = 1;
  UInt8 alignY = 2;
  UInt8 alignZ = 3;
  
  {
    for (UInt32 i =0; i<count; i++) {
      __evalXfosTask(i, this.xfos, this.posedCurveRef, this.params, keepArcLength, keepCurveLen, useLocalNormal, followCurveTangent, followCurveNormal, this.altTangent, this.altNormal);
      __evalCompressionTask(i, this.compression, this.posedCurveRef, this.restCurveRef, this.params, keepArcLength, keepCurveLen);
      Scalar localCompression = Float32(Math_linearInterpolate(1, this.compression[i], compressionAmt));
      this.xfos[i].sc = this.xfos[i].sc*Vec3(1,localCompression,localCompression);
      __alignXfosTask(i, this.outputsXfo, this.xfos, alignX, alignY, alignZ);
      outputs[i] = this.outputsXfo[i].toMat44();
    }
  }
}
