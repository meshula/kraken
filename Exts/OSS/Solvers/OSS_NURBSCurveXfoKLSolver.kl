require Math;
require Curves;
require InlineDrawing;

object OSS_NURBSCurveXfoKLSolver : KrakenSolver {
};

// Return Arguments for Kraken
function KrakenSolverArg[] OSS_NURBSCurveXfoKLSolver.getArguments() {
  KrakenSolverArg args[] = this.parent.getArguments();
  args.push(KrakenSolverArg('params', 'In', 'Scalar[]'));
  args.push(KrakenSolverArg('degree', 'In', 'SInt8'));
  args.push(KrakenSolverArg('keepArcLength', 'In', 'Scalar'));
  args.push(KrakenSolverArg('followCurveTangent', 'In', 'Scalar'));
  args.push(KrakenSolverArg('alignX', 'In', 'SInt8'));
  args.push(KrakenSolverArg('alignY', 'In', 'SInt8'));
  args.push(KrakenSolverArg('alignZ', 'In', 'SInt8'));
  args.push(KrakenSolverArg('altTangent', 'In', 'Vec3'));
  args.push(KrakenSolverArg('atVec', 'In', 'Mat44'));
  args.push(KrakenSolverArg('parent', 'In', 'Mat44'));
  args.push(KrakenSolverArg('compressionAmt', 'In', 'Scalar'));
  args.push(KrakenSolverArg('controlAligns', 'In', 'Vec3[]'));
  args.push(KrakenSolverArg('controlsRest', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('controls', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('outputs', 'Out', 'Mat44[]'));
  args.push(KrakenSolverArg('dummyResult', 'Out', 'Vec3'));
  return args;
}

// Solve
function OSS_NURBSCurveXfoKLSolver.solve!(
    in Boolean drawDebug,
    in Scalar rigScale,
    in Scalar params[],
    in SInt8 degree,
    in Scalar keepArcLength,
    in Scalar followCurveTangent,
    in SInt8 alignX,
    in SInt8 alignY,
    in SInt8 alignZ,
    in Vec3 altTangent,
    in Mat44 atVec,
    in Mat44 parent,
    in Scalar compressionAmt,
    in Vec3 controlAligns[],
    in Mat44 controlsRest[],
    in Mat44 controls[],
    io Mat44 outputs[],
    io Vec3 dummyResult
    )
{
  if(controls.size() != controlsRest.size())
    throw("Error in OSS_NURBSCurveXfoKLSolver. The number of controls must match the number of controlsRest. controls.size:" + controls.size() + "; constrainees.size:" + controlsRest.size() + "; controlAligns.size:" + controlAligns.size());

  UInt32 inCount  = controls.size();
  UInt32 outCount = params.size();
  Xfo posedXfo;
  Xfo restXfo;

  Scalar keepCurveLen = 0;
  outputs.resize(outCount);

  Mat44 alignedControls[];
  alignedControls.resize(inCount);
  Mat44 alignedControlsRest[];
  alignedControlsRest.resize(inCount);
  for (UInt32 i =0; i<inCount; i++) {
    alignedControls[i] = controls[i];
    alignedControls[i].align(controlAligns[i].x, controlAligns[i].y, controlAligns[i].z);
    alignedControlsRest[i] = controlsRest[i];
    alignedControlsRest[i].align(controlAligns[i].x, controlAligns[i].y, controlAligns[i].z);
  }

  NURBSCurve restCurve = NURBSCurve();
  NURBSCurve posedCurve = NURBSCurve();

  restCurve.initiate(alignedControlsRest, degree);
  posedCurve.initiate(alignedControls, degree);
  Ref <NURBSCurve> posedCurveRef = posedCurve;
  Ref <NURBSCurve> restCurveRef = restCurve;

  // positions = restCurve.positions.values;
  // colors  = restCurve.colors.values;
  // normals = restCurve.normals.values;
  
  Vec3 altNormals[];
  Vec3 altTangents[];
  Xfo xfos[];
  Vec3 positions[];
  Scalar compression[];

  altNormals.resize(outCount);
  altTangents.resize(outCount);
  xfos.resize(outCount);
  positions.resize(outCount);
  compression.resize(outCount);
  outputs.resize(outCount);

  Xfo parentXfo;
  parentXfo.setFromMat44(parent);
  Quat parentRotation = parentXfo.ori;
  Vec3 localAltTangent = parentRotation.rotateVector(altTangent);
  
  Scalar useLocalNormal = 1; 
  Scalar followCurveNormal = 1; 

  for (UInt32 i =0; i<outCount; i++) {
    positions[i]   = posedCurveRef.getPoint(params[i], keepArcLength, keepCurveLen);
    altNormals[i]  = positions[i] - parent.translation();
    
    altTangents[i] = localAltTangent;
    altNormals[i]  = positions[i] - parent.translation();
    __evalXfosTask(i, xfos, posedCurveRef, params, keepArcLength, 1, useLocalNormal, followCurveTangent, followCurveNormal, altTangents, altNormals);
    // __evalCompressionTask(i, compression, posedCurveRef, restCurveRef, params, keepArcLength, keepCurveLen);
    // Scalar localCompression = Math_linearInterpolate(1, compression[i], compressionAmt);
    // xfos[i].sc = xfos[i].sc*Vec3(1,localCompression,localCompression);
    xfos[i].sc = Vec3(1,1,1);
    outputs[i] = xfos[i].toMat44();
  }
  // Set debugging visibility.
  // this.setDebug(drawDebug);
  // if(this.drawDebug) {
  //   if(!this.handle)
  //     report('creating new handle');
  //     this.handle = DrawingHandle();
  //   // this.handle.drawAxesInstances('axes', outputs, dummyResult, instance);
  //   this.handle = DrawingHandle();

  //   handle.drawAxesInstances('axes', outputs, dummyResult, instance);
  //   drawLineStrip(this.handle.rootTransform, 'curve', positions, Color(1.0, 0.0, 0));
  //   InlinePointsShape myShape = drawPoints(root, 'tipPositions', positions, Color(0.0, 1.0, 0), 2);
  // }
}
