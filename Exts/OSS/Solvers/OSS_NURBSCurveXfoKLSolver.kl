require Math;
require Curves;
require InlineDrawing;


object OSS_NURBSCurveXfoKLSolver : KrakenSolver {
};


// Return Arguments for Kraken
function KrakenSolverArg[] OSS_NURBSCurveXfoKLSolver.getArguments() {
  KrakenSolverArg args[] = this.parent.getArguments();
  args.push(KrakenSolverArg('params', 'In', 'Scalar[]'));
  args.push(KrakenSolverArg('degree', 'In', 'SInt8'));
  args.push(KrakenSolverArg('keepArcLength', 'In', 'Scalar'));
  args.push(KrakenSolverArg('followCurveTangent', 'In', 'Scalar'));
  args.push(KrakenSolverArg('alignX', 'In', 'SInt8'));
  args.push(KrakenSolverArg('alignY', 'In', 'SInt8'));
  args.push(KrakenSolverArg('alignZ', 'In', 'SInt8'));
  args.push(KrakenSolverArg('altTangent', 'In', 'Vec3'));
  args.push(KrakenSolverArg('atVec', 'In', 'Mat44'));
  args.push(KrakenSolverArg('parent', 'In', 'Mat44'));
  args.push(KrakenSolverArg('compressionAmt', 'In', 'Scalar'));
  args.push(KrakenSolverArg('controlAligns', 'In', 'Vec3[]'));
  args.push(KrakenSolverArg('controlsRest', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('controls', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('outputs', 'Out', 'Mat44[]'));
  return args;
}


// Solve
function OSS_NURBSCurveXfoKLSolver.solve!(
    in Boolean drawDebug,
    in Scalar rigScale,
    in Scalar params[],
    in SInt8 degree,
    in Scalar keepArcLength,
    in Scalar followCurveTangent,
    in SInt8 alignX,
    in SInt8 alignY,
    in SInt8 alignZ,
    in Vec3 altTangent,
    in Mat44 atVec,
    in Mat44 parent,
    in Scalar compressionAmt,
    in Vec3 controlAligns[],
    in Mat44 controlsRest[],
    in Mat44 controls[],
    io Mat44 outputs[]
    )
{
  if(controls.size() != controlsRest.size())
    throw("Error in OSS_NURBSCurveXfoKLSolver. The number of controls must match the number of controlsRest. controls.size:" + controls.size() + "; constrainees.size:" + controlsRest.size() + "; controlAligns.size:" + controlAligns.size());

  UInt32 inCount  = controls.size();
  UInt32 outCount = params.size();
  Xfo posedXfo;
  Xfo restXfo;
  UInt8 tAlignX;
  UInt8 tAlignY;
  UInt8 tAlignZ;
  // realign the inputs
  // for (UInt32 i =0; i<inCount; i++) {
  //   posedXfo = Xfo(controls[i]);
  //   restXfo  = Xfo(controlsRest[i]);
  //   tAlignX = controlAligns[i].x;
  //   tAlignY = controlAligns[i].y;
  //   tAlignZ = controlAligns[i].z;
  //   posedXfo.align(tAlignX, tAlignY, tAlignZ);
  //   restXfo.align(tAlignX, tAlignY, tAlignZ);
  //   controls[i] = posedXfo.toMat44();
  //   controlsRest[i] = restXfo.toMat44();
  // }

  Scalar keepCurveLen = 0;
  
  outputs.resize(outCount);

  NURBSCurve restCurve = NURBSCurve();
  NURBSCurve posedCurve = NURBSCurve();

  restCurve.initiate(controlsRest, degree);
  posedCurve.initiate(controls, degree);
  // positions = restCurve.positions.values;
  // colors  = restCurve.colors.values;
  // normals = restCurve.normals.values;
  
  Vec3 altNormals[];
  altNormals.resize(outCount);

  Vec3 altTangents[];
  altTangents.resize(outCount);

  Xfo xfos[];
  xfos.resize(outCount);

  Vec3 positions[];
  positions.resize(outCount);
  
  Scalar compression[];
  compression.resize(outCount);

  Xfo parentXfo;
  parentXfo.setFromMat44(parent);

  Quat parentRotation = parentXfo.ori;
  Vec3 localAltTangent = parentRotation.rotateVector(altTangent);
  
  outputs.resize(outCount);
  
  Scalar useLocalNormal = 1; 
  Scalar followCurveNormal = 1; 

  Ref <NURBSCurve> posedCurveRef = posedCurve;
  Ref <NURBSCurve> restCurveRef = restCurve;
  
  for (UInt32 i =0; i<outCount; i++) {
    positions[i] = posedCurveRef.getPoint(params[i], keepArcLength, keepCurveLen);
    altNormals[i] = positions[i] - parent.translation();
    
    altTangents[i] = localAltTangent;
    altNormals[i] = positions[i] - parent.translation();
    __evalXfosTask(i, xfos, posedCurveRef, params, keepArcLength, keepCurveLen, useLocalNormal, followCurveTangent, followCurveNormal, altTangents, altNormals);
    __evalCompressionTask(i, compression, posedCurveRef, restCurveRef, params, keepArcLength, keepCurveLen);

    Scalar localCompression = Scalar(Math_linearInterpolate(1, compression[i], compressionAmt));
    xfos[i].sc = xfos[i].sc*Vec3(1,localCompression,localCompression);
    xfos[i].align(alignX, alignY, alignZ);
    outputs[i] = xfos[i].toMat44();
  }
}
