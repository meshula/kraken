require Math;
require Curves;
require InlineDrawing;



struct OSS_NURBSCurveXfoKLSolverDefaults : KrakenSolverDefaults {
    SInt8 degree;
    Scalar keepArcLength;
    Scalar followCurveTangent;
    Scalar useLocalNormal;
    Scalar followCurveNormal;
    SInt8 alignX;
    SInt8 alignY;
    SInt8 alignZ;
    Vec3 altTangent;
    Scalar compressionAmt;
};

// Default Constructor
function OSS_NURBSCurveXfoKLSolverDefaults()
{
    this.degree = 3;
    this.keepArcLength = 0;
    this.followCurveTangent = 1.0;
    this.useLocalNormal = 1.0;
    this.followCurveNormal = 1.0;
    this.alignX = 1;
    this.alignY = 2;
    this.alignZ = 3;
    this.altTangent = Vec3(1,0,0);
    this.compressionAmt = 0;
}

object OSS_NURBSCurveXfoKLSolver : KrakenSolver {
    OSS_NURBSCurveXfoKLSolverDefaults defaults;
};

// Return Arguments for Kraken
function KrakenSolverArg[] OSS_NURBSCurveXfoKLSolver.getArguments() {
  KrakenSolverArg args[] = this.parent.getArguments();
  args.push(KrakenSolverArg('params', 'In', 'Scalar[]'));
  args.push(KrakenSolverArg('degree', 'In', 'SInt8'));
  args.push(KrakenSolverArg('keepArcLength', 'In', 'Scalar'));
  args.push(KrakenSolverArg('followCurveTangent', 'In', 'Scalar'));
  args.push(KrakenSolverArg('useLocalNormal', 'In', 'Scalar'));
  args.push(KrakenSolverArg('followCurveNormal', 'In', 'Scalar'));
  args.push(KrakenSolverArg('alignX', 'In', 'SInt8'));
  args.push(KrakenSolverArg('alignY', 'In', 'SInt8'));
  args.push(KrakenSolverArg('alignZ', 'In', 'SInt8'));
  args.push(KrakenSolverArg('altTangent', 'In', 'Vec3'));
  args.push(KrakenSolverArg('atVec', 'In', 'Mat44'));
  args.push(KrakenSolverArg('parent', 'In', 'Mat44'));
  args.push(KrakenSolverArg('compressionAmt', 'In', 'Scalar'));
  args.push(KrakenSolverArg('controlAligns', 'In', 'Vec3[]'));
  args.push(KrakenSolverArg('controlsRest', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('controls', 'In', 'Mat44[]'));
  args.push(KrakenSolverArg('outputs', 'Out', 'Mat44[]'));
  args.push(KrakenSolverArg('dummyResult', 'Out', 'Vec3'));
  args.push(KrakenSolverArg('instance', 'Out', 'InlineInstance'));
  return args;
}

function InlineLinesShape drawLines(
  io InlineTransform rootTransform,
  in String name,
  in Vec3 starts[],
  in Vec3 ends[],
  in Color color
){
  if(starts.size() != ends.size())
    throw("Error: the end and start point need to be of equal size");

  InlineLinesShape linesShape = getOrCreateLines(rootTransform, name, color);
  Lines lines = linesShape.getLines();
  lines.clear();
  for (UInt32 i =0; i<starts.size(); i++) {
    lines.addLine(starts[i], ends[i]);
  }
  return linesShape;
}
// Solve
function OSS_NURBSCurveXfoKLSolver.solve!(
    in Boolean drawDebug,
    in Scalar rigScale,
    in Scalar params[],
    in SInt8 degree,
    in Scalar keepArcLength,
    in Scalar followCurveTangent,
    in Scalar useLocalNormal,
    in Scalar followCurveNormal,
    in SInt8 alignX,
    in SInt8 alignY,
    in SInt8 alignZ,
    in Vec3 altTangent,
    in Mat44 atVec,
    in Mat44 parent,
    in Scalar compressionAmt,
    in Vec3 controlAligns[],
    in Mat44 controlsRest[],
    in Mat44 controls[],
    io Mat44 outputs[],
    out Vec3 dummyResult,
    out InlineInstance instance
    )
{
  if(controls.size() != controlsRest.size())
    throw("Error in OSS_NURBSCurveXfoKLSolver. The number of controls must match the number of controlsRest.\n\tcontrols.size:" + controls.size() + "\n\tcontrolsRest.size:" + controlsRest.size() + "\n\n\tcontrolAligns.size:" + controlAligns.size() + "\n\tparams.size:" + params.size());


  UInt32 inCount  = controls.size();
  UInt32 outCount = params.size();

  Xfo posedXfo;
  Xfo restXfo;

  Scalar keepCurveLen = 0;
  outputs.resize(outCount);

  /// Align Controls according to main Curve Direction, given the controlAligns Input array
  Mat44 alignedControls[];
  alignedControls.resize(inCount);
  Mat44 alignedControlsRest[];
  alignedControlsRest.resize(inCount);
  for (UInt32 i =0; i<inCount; i++) {
    alignedControls[i] = controls[i];
    alignedControls[i].align(controlAligns[i].x, controlAligns[i].y, controlAligns[i].z);
    alignedControlsRest[i] = controlsRest[i];
    alignedControlsRest[i].align(controlAligns[i].x, controlAligns[i].y, controlAligns[i].z);
  }

  NURBSCurve restCurve = NURBSCurve();
  NURBSCurve posedCurve = NURBSCurve();

  restCurve.initiate(alignedControlsRest, degree);
  posedCurve.initiate(alignedControls, degree);
  Ref <NURBSCurve> posedCurveRef = posedCurve;
  Ref <NURBSCurve> restCurveRef = restCurve;
  // positions = restCurve.positions.values;
  // colors  = restCurve.colors.values;
  // normals = restCurve.normals.values;
  
  Vec3 altNormals[];
  Vec3 altTangents[];
  Xfo xfos[];
  Vec3 positions[];
  Vec3 tangents[];
  //Vec3 lineTangents[];
  Scalar compression[];
  altNormals.resize(outCount);
  altTangents.resize(outCount);
  xfos.resize(outCount);
  positions.resize(outCount);
  compression.resize(outCount);
  outputs.resize(outCount);
  tangents.resize(outCount);
  //lineTangents.resize(outCount);
  Xfo parentXfo;
  parentXfo.setFromMat44(parent);
  Quat parentRotation = parentXfo.ori;
  Vec3 localAltTangent = parentRotation.rotateVector(altTangent);
  
  Xfo controlsXfo[];
  Xfo alignedControlsXfo[];
  controlsXfo.resize(inCount);
  alignedControlsXfo.resize(inCount);
  for (UInt32 i =0; i<inCount; i++) {
      controlsXfo[i].setFromMat44(controls[i]);
      alignedControlsXfo[i].setFromMat44(alignedControls[i]);
  }
  
  for (UInt32 i =0; i<outCount; i++) {
    positions[i]   = posedCurveRef.getPoint(params[i], keepArcLength, keepCurveLen);
    tangents[i] = posedCurveRef.getTangent(params[i], true, keepArcLength, keepCurveLen);
    // lineTangents[i] = positions[i] + tangents[i];
    altTangents[i] = localAltTangent;
    altNormals[i]  = parent.translation() - positions[i];
    __evalXfosTask(i, xfos, posedCurveRef, params, keepArcLength, keepCurveLen, useLocalNormal, followCurveTangent, followCurveNormal, altTangents, altNormals);
    __evalCompressionTask(i, compression, posedCurveRef, restCurveRef, params, keepArcLength, keepCurveLen);
    Scalar localCompression = Math_linearInterpolate(1, compression[i], compressionAmt);
    xfos[i].sc = xfos[i].sc*Vec3(1,localCompression,localCompression);
    xfos[i].align(alignX,alignY,alignZ);
    outputs[i] = xfos[i].toMat44();
  }
  
  // Set debugging visibility.
  this.handle =  DrawingHandle();
  InlineTransform root = this.handle.getRootTransform();
  if(drawDebug) {
    if(!this.handle)
      this.handle = DrawingHandle();
    // drawLines(root, 'Tangents', positions, lineTangents, Color(0.5, 0.0, 0,1));
    this.handle.drawAxesInstances('controls', xfos, dummyResult, instance);
  }
}
