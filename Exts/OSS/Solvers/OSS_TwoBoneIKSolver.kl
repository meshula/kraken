require InlineDrawing;
require Geometry;
require Kraken;

object OSS_TwoBoneIKSolver : KrakenSolver {
  Xfo initPose[];
};

// Default Constructor
function OSS_TwoBoneIKSolver()
{

}

function OSS_TwoBoneIKSolver(
  Xfo initPose[])
{
  this.initPose = initPose;
}


// Return Arguments for Kraken
function KrakenSolverArg[] OSS_TwoBoneIKSolver.getArguments(){
  KrakenSolverArg args[] = this.parent.getArguments();

  args.push(KrakenSolverArg('ikBlend', 'In', 'Scalar'));
  args.push(KrakenSolverArg('softDist', 'In', 'Scalar'));
  args.push(KrakenSolverArg('stretch', 'In', 'Scalar'));

  args.push(KrakenSolverArg('root', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone0FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone1FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('ikHandle', 'In', 'Mat44'));
  args.push(KrakenSolverArg('upV', 'In', 'Mat44'));
  args.push(KrakenSolverArg('boneAxis', 'In', 'UInt32'));
  args.push(KrakenSolverArg('upAxis', 'In', 'UInt32'));

  args.push(KrakenSolverArg('bone0Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('bone1Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('bone0Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('bone1Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('bone2Out', 'Out', 'Mat44'));
  return args;
}


require Math;
require Animation;


function oss_solve2BoneIK(
  in Scalar bone0Length,
  in Scalar bone1Length,
  in Vec3 rootPosition,
  in Vec3 upVPosition,
  in Vec3 goalPosition,
  io Xfo bone0Xfo,
  io Xfo bone1Xfo
) {

  Vec3 rootToGoal = goalPosition - rootPosition;
  Vec3 rootToUpV = upVPosition - rootPosition;

  bone0Xfo.tr = rootPosition;

  Vec3 xaxis = rootToGoal.unit();
  Vec3 zaxis = xaxis.cross(rootToUpV.unit()).cross(xaxis).unit();
  Vec3 yaxis = zaxis.cross(xaxis).unit();
  bone0Xfo.ori.setFromMat33(Mat33(xaxis, yaxis, zaxis).transpose());

  Scalar distToIkGoal = rootToGoal.length();
  // Use trigonometry to determine the ikBoneAngle
  // Law of cosines. a = BoneLength; b = Child BoneLength; c = Distance to the Ik Goal;
  Scalar ikBoneAngle = acos(Math_clamp((sq(bone0Length) + sq(distToIkGoal) - sq(bone1Length)) / (2.0 * bone0Length * distToIkGoal), - 1.0, 1.0));

  // Apply the rotation in the coordinate space of the bone.
  Quat offset;
  offset.setFromAxisAndAngle(Vec3(0.0, -1.0, 0.0), ikBoneAngle);
  bone0Xfo.ori = bone0Xfo.ori * offset;

  // transform the vector without applying scale.
  bone1Xfo.tr = bone0Xfo.tr + bone0Xfo.ori.rotateVector(Vec3(bone0Length, 0.0, 0.0));
  bone1Xfo.ori = bone0Xfo.ori;

  offset.setFrom2Vectors(bone1Xfo.ori.getXaxis(), (goalPosition - bone1Xfo.tr).unit());
  bone1Xfo.ori = offset * bone1Xfo.ori;
}


// Gotta be a better way
function Vec3 getAxisAsVector(in UInt32 axisIndex)
{
  Vec3 vec;
  switch (axisIndex)
  {
    case 0:
      return Vec3(1.0, 0.0, 0.0);
    case 1:
      return Vec3(0.0, 1.0, 0.0);
    case 2:
      return Vec3(0.0, 0.0, 1.0);
    case 3:
      return Vec3(-1.0, 0.0, 0.0);
    case 4:
      return Vec3(0.0, -1.0, 0.0);
    case 5:
      return Vec3(0.0, 0.0, -1.0);
  }
  report("OSS_TwoBoneIKSolver:getAxisAsVector() invalid axisIndex");
  return Vec3(1.0, 0.0, 0.0);
}

function Vec3 getAxis(in Quat ori, in UInt32 axisIndex)
{
  switch (axisIndex)
  {
    case 0:
      return ori.getXaxis();
    case 1:
      return ori.getYaxis();
    case 2:
      return ori.getZaxis();
    case 3:
      return ori.getXaxis().negate();
    case 4:
      return ori.getYaxis().negate();
    case 5:
      return ori.getZaxis().negate();
  }
  report("OSS_TwoBoneIKSolver:getAxis() invalid axisIndex");
  return ori.getXaxis();

}

// Make this take in a specific aim and upvector later
// Hard-coded to aim pos +X and use +Z as normal
function setCorrectAxes(
  in Xfo inXfo,
  in UInt32 boneAxis,
  in UInt32 upAxis,
  io Xfo outXfo
  ) {

    Vec3 aimAxisVec = getAxis(inXfo.ori, boneAxis).unit();
    Vec3 upAxisVec = getAxis(inXfo.ori, upAxis).unit();
    Vec3 normalAxisVec = upAxisVec.cross(aimAxisVec).unit();
    Mat33 mat(aimAxisVec, normalAxisVec, upAxisVec);

    outXfo.ori.setFromMat33(mat.transpose());
}


// Solve
function OSS_TwoBoneIKSolver.solve!
(
  Boolean drawDebug,
  Scalar rigScale,

  Scalar ikBlend,
  Scalar softDist,
  Scalar stretch,

  Mat44 root,
  Mat44 bone0FK,
  Mat44 bone1FK,
  Mat44 ikHandle,
  Mat44 upV,
  UInt32 boneAxis,
  UInt32 upAxis,

  Scalar bone0Len,
  Scalar bone1Len,
  io Mat44 bone0Out,
  io Mat44 bone1Out,
  io Mat44 bone2Out
){
  Xfo bone0FkXfo = Xfo(bone0FK);
  Xfo bone1FkXfo = Xfo(bone1FK);
  Xfo bone0Xfo = bone0FkXfo;
  Xfo bone1Xfo = bone1FkXfo;
  Xfo bone2Xfo;

  Xfo ikHandleXfo = Xfo(ikHandle);

  Scalar bone0Length = bone0Len;
  Scalar bone1Length = bone1Len;

  Scalar bone0LenRigScaled = bone0Length * rigScale;
  Scalar bone1LenRigScaled = bone1Length * rigScale;

  Scalar softDistRigScaled = softDist * rigScale;  //Make sure

  Scalar stretchedRatio = 1.0;  //De;ete this

  Vec3 ikGoalPos = ikHandleXfo.tr;
  Vec3 straightLegGoalPos = ikGoalPos;

  Xfo debugXfo;
  Xfo debugXfo2;
  Xfo ikGoalPosXfoDebug;

  if(ikBlend > 0) {

    Scalar distanceOrig = ikHandleXfo.tr.distanceTo(bone0Xfo.tr);
    Scalar distance = distanceOrig;

    if (softDist > 0 && (bone0LenRigScaled + bone1LenRigScaled) - distance < softDist)
    {

      //
      Scalar hardDist = bone0LenRigScaled + bone1LenRigScaled - softDist;

      distance = softDist * (1-exp (-(distance-hardDist) / softDist)) + hardDist;

      // Move ik goal position
      Vec3 difference = ikHandleXfo.tr - bone0FkXfo.tr;
      difference = difference * (distance / distanceOrig);

      if (difference.length()) {
        difference.unit();
        straightLegGoalPos = bone0FkXfo.tr + (difference.unit() * (bone0LenRigScaled + bone1LenRigScaled));
        debugXfo2.tr =   straightLegGoalPos;
      }

      ikGoalPos = bone0FkXfo.tr + difference;

      Vec3 ikGoalDiff =  ikGoalPos - straightLegGoalPos;

      Scalar legLength = (straightLegGoalPos - bone0FkXfo.tr).length();
      Scalar IKLength = (ikHandleXfo.tr - bone0FkXfo.tr).length();

      // If the ik handle is farther away than a straight-leg
      if (IKLength > legLength)
      {
        ikGoalPos = ikHandleXfo.tr + ikGoalDiff;
        ikGoalPosXfoDebug.tr = ikGoalPos;
      }

      //bone0Length *= (newDist / hardDist);
      //bone1Length *= (newDist / hardDist);
      //bone0LenRigScaled = bone0Length * rigScale;
      //bone1LenRigScaled = bone1Length * rigScale;
    }


    if(stretch > 0)
    {
      if (distanceOrig > bone0LenRigScaled + bone1LenRigScaled)
      {
        Scalar distance2 = (stretch * (distanceOrig - (bone0LenRigScaled + bone1LenRigScaled))) + (bone0LenRigScaled + bone1LenRigScaled);

        bone0Length *= (distance2 / (bone0LenRigScaled + bone1LenRigScaled));
        bone1Length *= (distance2 / (bone0LenRigScaled + bone1LenRigScaled));
        bone0LenRigScaled = bone0Length * rigScale;
        bone1LenRigScaled = bone1Length * rigScale;
      }

    } else
    {
      //distance = bone0LenRigScaled + bone1LenRigScaled;
    }

    oss_solve2BoneIK(
      bone0LenRigScaled,
      bone1LenRigScaled,
      root.translation(),
      upV.translation(),
      ikGoalPos,
      bone0Xfo,
      bone1Xfo
    );

    // Because of the way oss_solve2BoneIK treats the upvector (z)
    // Perhaps we can re-write to solve in the correct axes eventually, but for now this should work
    UInt32 upAxisInt = upAxis;
    // if (upAxisInt > 2)
    // {
    //   upAxisInt = upAxisInt - 3;
    // }

    setCorrectAxes(bone0Xfo, boneAxis, upAxisInt, bone0Xfo);
    setCorrectAxes(bone1Xfo, boneAxis, upAxisInt, bone1Xfo);
    setCorrectAxes(bone2Xfo, boneAxis, upAxisInt, bone2Xfo);

    bone0Xfo.ori = bone0FkXfo.ori.sphericalLinearInterpolate(bone0Xfo.ori, ikBlend);
    bone1Xfo.tr = bone0Xfo.transformVector((stretchedRatio * bone0Length) * getAxisAsVector(boneAxis) );
    bone1Xfo.ori = bone1FkXfo.ori.sphericalLinearInterpolate(bone1Xfo.ori, ikBlend);
  }

  // project bone2 to the end of bone 1
  bone2Xfo = bone1Xfo;
  bone2Xfo.tr = bone1Xfo.transformVector((stretchedRatio * bone1Length) * getAxisAsVector(boneAxis));
  // softdist may pull the foot away from ik goal, put it back
  //bone2Xfo.tr = ikHandleXfo.tr;

  // Set scaling
  Vec3 outScaling = Vec3(rigScale, rigScale, rigScale);
  bone0Xfo.sc = outScaling;
  bone1Xfo.sc = outScaling;
  bone2Xfo.sc = outScaling;

  bone0Out = bone0Xfo.toMat44();
  bone1Out = bone1Xfo.toMat44();
  bone2Out = bone2Xfo.toMat44();

  debugXfo.tr = ikHandleXfo.tr;

  // Set debugging visibility.
  this.setDebug(drawDebug);
  if(this.drawDebug){

    Color blueColor(0.0, 0.0, 1.0);
    Color redColor(1.0, 0.0, 0.0);
    Color greenColor(0.0, 1.0, 0.0);
    etDrawBone(this.handle.rootTransform, 'debug', debugXfo, 0.2,  0.2, blueColor);
    etDrawBone(this.handle.rootTransform, 'debug2', debugXfo2, 0.2,  0.2, redColor);
    etDrawBone(this.handle.rootTransform, 'debug3', ikGoalPosXfoDebug, 0.2,  0.2, greenColor);

    //etDrawBone(this.handle.rootTransform, 'bone1', bone1Xfo, bone1LenRigScaled, bone1LenRigScaled * 0.15, boneColor);
  }
}
