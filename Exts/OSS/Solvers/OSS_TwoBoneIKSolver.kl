require InlineDrawing;
require Geometry;
require Kraken;


object OSS_TwoBoneIKSolver : KrakenSolver {
};

// Default Constructor
function OSS_TwoBoneIKSolver()
{
  this.defaultValues["ikBlend"] = 0.5;
  this.defaultValues["softIK"] = 0.0;
  this.defaultValues["squash"] = 0.0;
  this.defaultValues["stretch"] = 0.0;
  this.defaultValues["root"] = Mat44();
  this.defaultValues["bone0FK"] = Mat44();
  this.defaultValues["bone1FK"] = Mat44();
  this.defaultValues["ikHandle"] = Mat44();
  this.defaultValues["upV"] = Mat44();
  this.defaultValues["boneAxis"] = 0;
  this.defaultValues["upAxis"] = 1;
  this.defaultValues["upV"] =  Mat44();
  this.defaultValues["bone0Len"] = 1.0;
  this.defaultValues["bone1Len"] = 1.0;
}


// Return Arguments for Kraken
function KrakenSolverArg[] OSS_TwoBoneIKSolver.getArguments(){
  KrakenSolverArg args[] = this.parent.getArguments();

  args.push(KrakenSolverArg('ikBlend', 'In', 'Scalar'));
  args.push(KrakenSolverArg('softIK', 'In', 'Scalar'));
  args.push(KrakenSolverArg('squash', 'In', 'Scalar'));
  args.push(KrakenSolverArg('stretch', 'In', 'Scalar'));

  args.push(KrakenSolverArg('root', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone0FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('bone1FK', 'In', 'Mat44'));
  args.push(KrakenSolverArg('ikHandle', 'In', 'Mat44'));
  args.push(KrakenSolverArg('upV', 'In', 'Mat44'));
  args.push(KrakenSolverArg('boneAxis', 'In', 'UInt32'));
  args.push(KrakenSolverArg('upAxis', 'In', 'UInt32'));

  args.push(KrakenSolverArg('bone0Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('bone1Len', 'In', 'Scalar'));
  args.push(KrakenSolverArg('bone0Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('bone1Out', 'Out', 'Mat44'));
  args.push(KrakenSolverArg('bone2Out', 'Out', 'Mat44'));
  return args;
}


require Math;
require Animation;


function oss_solve2BoneIK(
  in Scalar bone0Length,
  in Scalar bone1Length,
  in Vec3 rootPosition,
  in Vec3 upVPosition,
  in Vec3 goalPosition,
  in Vec3 realGoalPosition,
  io Xfo bone0Xfo,
  io Xfo bone1Xfo
) {

  // goalPosition = position to calculate the two boneIK
  // realGoalPosition = position of the actual ikGoal (will only be different if using softIK value, for exmple)

  Vec3 rootToGoal = goalPosition - rootPosition;
  Vec3 rootToUpV = upVPosition - rootPosition;

  bone0Xfo.tr = rootPosition;

  Vec3 xaxis = rootToGoal.unit();
  Vec3 zaxis = xaxis.cross(rootToUpV.unit()).cross(xaxis).unit();
  Vec3 yaxis = zaxis.cross(xaxis).unit();
  bone0Xfo.ori.setFromMat33(Mat33(xaxis, yaxis, zaxis).transpose());

  Scalar distToIkGoal = rootToGoal.length();
  // Use trigonometry to determine the ikBoneAngle
  // Law of cosines. a = BoneLength; b = Child BoneLength; c = Distance to the Ik Goal;
  Scalar ikBoneAngle = acos(Math_clamp((sq(bone0Length) + sq(distToIkGoal) - sq(bone1Length)) / (2.0 * bone0Length * distToIkGoal), - 1.0, 1.0));

  // Apply the rotation in the coordinate space of the bone.
  Quat offset;
  offset.setFromAxisAndAngle(Vec3(0.0, -1.0, 0.0), ikBoneAngle);
  bone0Xfo.ori = bone0Xfo.ori * offset;

  // transform the vector without applying scale.
  bone1Xfo.tr = bone0Xfo.tr + bone0Xfo.ori.rotateVector(Vec3(bone0Length, 0.0, 0.0));
  bone1Xfo.ori = bone0Xfo.ori;

  offset.setFrom2Vectors(bone1Xfo.ori.getXaxis(), (realGoalPosition - bone1Xfo.tr).unit());
  bone1Xfo.ori = offset * bone1Xfo.ori;
}





// Solve
function OSS_TwoBoneIKSolver.solve!(
  Boolean drawDebug,
  Scalar rigScale,
  Scalar ikBlend,
  Scalar softIK,
  Scalar squash,
  Scalar stretch,
  Mat44 root,
  Mat44 bone0FK,
  Mat44 bone1FK,
  Mat44 ikHandle,
  Mat44 upV,
  UInt32 boneAxis,
  UInt32 upAxis,
  Scalar bone0Len,
  Scalar bone1Len,
  io Mat44 bone0Out,
  io Mat44 bone1Out,
  io Mat44 bone2Out
){
  Xfo bone0FkXfo = Xfo(bone0FK);
  Xfo bone1FkXfo = Xfo(bone1FK);
  Xfo bone0Xfo = bone0FkXfo;
  Xfo bone1Xfo = bone1FkXfo;
  Xfo bone2Xfo;

  Xfo ikHandleXfo = Xfo(ikHandle);

  Scalar bone0Length = bone0Len;
  Scalar bone1Length = bone1Len;

  Scalar bone0LenRigScaled = bone0Length * rigScale;
  Scalar bone1LenRigScaled = bone1Length * rigScale;

  Scalar legLength = (bone0LenRigScaled + bone1LenRigScaled);

  Scalar softIKRigScaled = softIK * rigScale;  //Make sure

  Scalar stretchedRatio = 1.0;  //Delete this

  Vec3 ikHandlePos = ikHandleXfo.tr;
  Vec3 ikGoalPos = ikHandlePos;

  Vec3 base2handleVec = ikHandleXfo.tr - bone0FkXfo.tr;
  Scalar base2handleDistance = ikHandleXfo.tr.distanceTo(bone0Xfo.tr);
  Scalar base2goalDistance = base2handleDistance; // May be changed by damping, etc
  Vec3 straightLegGoalPos = bone0FkXfo.tr + (base2handleVec.unit() * legLength);

  Scalar damping = softIK * (1.0-squash);  // Turn off damping when squash is on / helps paritally, but not a great solution

  if(ikBlend > 0) {

    // Damping distance will change the IK goal position
    if (damping > 0 && legLength - base2handleDistance < damping) // If ik goal is within damping range...
    {
      //
      Scalar hardDist = legLength - damping;
      base2goalDistance = damping * (1-exp (-(base2handleDistance-hardDist) / damping)) + hardDist;

      // Move ik goal position
      Vec3 base2goalVec = base2handleVec * (base2goalDistance / base2handleDistance);
      ikGoalPos = bone0FkXfo.tr + base2goalVec;

      Vec3 ikGoalDiff =  ikGoalPos - straightLegGoalPos;

      // If the ik handle is farther away than a straight-leg
      if (stretch > 0 && base2handleDistance > legLength)
      {
        ikGoalPos = ikHandleXfo.tr + ikGoalDiff;
      }
      //bone0Length *= (newDist / hardDist);
      //bone1Length *= (newDist / hardDist);
      //bone0LenRigScaled = bone0Length * rigScale;
      //bone1LenRigScaled = bone1Length * rigScale;
    }
    if (squash > 0)
    {
      if (base2handleDistance < legLength)
      {
        Scalar squashedLegLength = (legLength - squash * (legLength - base2handleDistance) );
        bone0Length *= (squashedLegLength / legLength);
        bone1Length *= (squashedLegLength / legLength);
        bone0LenRigScaled = bone0Length * rigScale;
        bone1LenRigScaled = bone1Length * rigScale;
        legLength = squashedLegLength;
      }
    }

    if (stretch > 0)
    {
      if (base2handleDistance > legLength)
      {
        Scalar stretchedLegLength = (stretch * (base2handleDistance - legLength)) + legLength;

        bone0Length *= (stretchedLegLength / legLength);
        bone1Length *= (stretchedLegLength / legLength);
        bone0LenRigScaled = bone0Length * rigScale;
        bone1LenRigScaled = bone1Length * rigScale;
        legLength = stretchedLegLength;
      }

    } else
    {
      //distance = bone0LenRigScaled + bone1LenRigScaled;
    }

    oss_solve2BoneIK(
      bone0LenRigScaled,
      bone1LenRigScaled,
      root.translation(),
      upV.translation(),
      ikGoalPos,
      ikHandlePos,
      bone0Xfo,
      bone1Xfo
    );

    // Because of the way oss_solve2BoneIK treats the upvector (z)
    // Perhaps we can re-write to solve in the correct axes eventually, but for now this should work
    UInt32 upAxisInt = upAxis;
    // if (upAxisInt > 2)
    // {
    //   upAxisInt = upAxisInt - 3;
    // }

    setCorrectAxes(bone0Xfo, boneAxis, upAxisInt, bone0Xfo);
    setCorrectAxes(bone1Xfo, boneAxis, upAxisInt, bone1Xfo);
    setCorrectAxes(bone2Xfo, boneAxis, upAxisInt, bone2Xfo);

    // Blend orientation of IK solution to FK
    bone0Xfo.ori = bone0FkXfo.ori.sphericalLinearInterpolate(bone0Xfo.ori, ikBlend);
    bone1Xfo.tr = bone0Xfo.transformVector((stretchedRatio * bone0Length) * getAxisAsVector(boneAxis) );
    bone1Xfo.ori = bone1FkXfo.ori.sphericalLinearInterpolate(bone1Xfo.ori, ikBlend);
  }

  // project bone2 to the end of bone 1
  bone2Xfo = bone1Xfo;

  Scalar blend = stretch;
  if (base2handleDistance < legLength)  //if
    blend = 1.0;

  Scalar ikBone1Length = bone1Xfo.tr.distanceTo(straightLegGoalPos.linearInterpolate(ikHandlePos, blend));
  Scalar adjustedBone1Length = bone1LenRigScaled.linearInterpolate(ikBone1Length, ikBlend);

  bone2Xfo.tr = bone1Xfo.transformVector(adjustedBone1Length * getAxisAsVector(boneAxis));
  // If we are reoriented bone1 because of softIK, bone1Length needs to be lengthened to reach the original goal
  // Note, lower limb will be slightly longer than upper, but should be negligible
  //bone2Xfo.tr = bone2Xfo.transformVector((bone2Xfo.tr.distanceTo(ikHandlePos)) * getAxisAsVector(boneAxis));

  //if (base2handleDistance > legLength)  // If leg is straight
  //  bone2Xfo.tr = straightLegGoalPos.linearInterpolate(ikHandlePos, stretch);  // Find out if linearInterpolate is optimized at 0,1
  //else
  //  bone2Xfo.tr = ikHandlePos;



  // softIK may pull the foot away from ik goal, put it back
  //bone2Xfo.tr = ikHandleXfo.tr;

  // Set scaling
  Vec3 outScaling = Vec3(rigScale, rigScale, rigScale);
  bone0Xfo.sc = outScaling;
  bone1Xfo.sc = outScaling;
  bone2Xfo.sc = outScaling;

  bone0Out = bone0Xfo.toMat44();
  bone1Out = bone1Xfo.toMat44();
  bone2Out = bone2Xfo.toMat44();

  // Set debugging visibility.

  this.setDebug(drawDebug);
  if(this.drawDebug){
    if(!this.handle)
      this.handle = DrawingHandle();
    Color yellowColor(1.0, 1.0, 0.0);
    Color blueColor(0.0, 0.0, 1.0);
    Color redColor(1.0, 0.0, 0.0);
    Color greenColor(0.0, 1.0, 0.0);
    Color cyanColor(0.0, 1.0, 1.0);
    //etDrawBone(this.handle.rootTransform, 'debug', ikHandleXfo, 0.2,  0.2, blueColor);
    //etDrawBone(this.handle.rootTransform, 'debug1', debugXfo, 0.2,  0.2, yellowColor);
    etDrawBone(this.handle.rootTransform, 'debug2', Xfo(straightLegGoalPos), 0.2,  0.2, redColor);
    etDrawBone(this.handle.rootTransform, 'debug3', Xfo(ikGoalPos), 0.2,  0.2, greenColor);
    etDrawBone(this.handle.rootTransform, 'debug4', Xfo(ikHandlePos), 0.1,  0.1, cyanColor);

    //etDrawBone(this.handle.rootTransform, 'bone1', bone1Xfo, bone1LenRigScaled, bone1LenRigScaled * 0.15, boneColor);
  }
}
